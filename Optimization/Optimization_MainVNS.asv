clear all
close all
clc

%% Optimization by Golden Section Method (minimize negative mean profit)

% Initialization
scenario = NewDay([]);

%% Greedy Search Method - Construction heuristic
InSeats=200;
problem.i_SOLUTION = GreedySeats(InSeats, scenario);  % candidate arrangement
Profit = Run_Simulation(problem.i_SOLUTION);  % profit

% Used to collect number of seats investigated
ak_all = [];

%% VNS 
%initialization
dummy=1;
new_sol=problem.i_SOLUTION; 
new_val=Profit;
current_val=inf;
tic                                 % start time
while new_val>current_val
    %if a neighbor improves the solution, then we store and we keep searching    
    current_sol=new_sol;
    current_val=new_val;
    solutions(:,dummy)=current_sol; %each column is a new column
    values(:,dummy)=current_val;
    aux_break=0;
    
        %1st local search: Split Tables (1,2,3...)
        %1.1
        new_table_ar = table_neighborSM1(current_sol,0);
        for i=1:size(new_table_ar,2)
            new_val = Run_Simulation(new_table_ar(:,i));
            if new_val>current_val
                aux_break=1;
                break
            end
        end
        %1.2
        if aux_break==0
             new_table_ar = table_neighborSM2(current_sol,0);
            for i=1:size(new_table_ar,2)
                new_val = Run_Simulation(new_table_ar(:,i));
                if new_val>current_val
                    aux_break=1;
                    break
                end
            end
        end
    
        %2nd local search: Merge Tables (2,3,4...)
         %2.1
        new_table_ar = table_neighborSM1(current_sol,1);
        for i=1:size(new_table_ar,2)
            new_val = Run_Simulation(new_table_ar(:,i));
            if new_val>current_val
                aux_break=1;
                break
            end
        end
        %2.2
        if aux_break==0
             new_table_ar = table_neighborSM2(current_sol,1);
            for i=1:size(new_table_ar,2)
                new_val = Run_Simulation(new_table_ar(:,i));
                if new_val>current_val
                    aux_break=1;
                    break
                end
            end
        end
        
        %3rd local search: Add Tables (1,2,3,...)
        n=1;
        while aux_break==0 && n<6
            new_table_ar=table_neighborARN(current_sol,0,n);
                for i=1:size(new_table_ar,2)
                    new_val = Run_Simulation(new_table_ar(:,i));
                    if new_val>current_val
                        aux_break=1;
                        break
                    end
                end
           n=n+1;
        end
               
        %4th local search: Remove Tables (1,2,3...)
        n=1;
        while aux_break==0 && n<6
            new_table_ar=table_neighborARN(current_sol,1,n);
                for i=1:size(new_table_ar,2)
                    new_val = Run_Simulation(new_table_ar(:,i));
                    if new_val>current_val
                        aux_break=1;
                        break
                    end
                end
           n=n+1;
        end

    end
    
   
end
toc                                    % end time
opt_ak_gm = GreedySeats(ak, scenario);
opt_bk_gm = GreedySeats(bk, scenario);
fprintf('The optimal number of seats lies in interval: [%d %d]\n', ak, bk);
fprintf('The optimal profit lies is about: %d\n', (-Profit + -theta_mk)/2);
disp(opt_ak_gm)
disp(opt_bk_gm)

%% Simulated Annealing Method (Hybrid with Greedy Method)

% Define parameters for simulated annealing (optimizing table arrangement)
problem.M = 20;                          % Number of temperature changes
problem.K = 10;                          % Number of iterations per level of temperature
problem.D = 100;                        % Average increase of the objective function
problem.P0 = 0.999;                     % Initial acceptance probability
problem.Pf = 0.00001;                   % Final acceptance probability
problem.RANDOMIZE1 = @table_neighbor1;     
problem.RANDOMIZE2 = @table_neighbor2; 
problem.OBJECTIVE_FUNCTION = @Run_Simulation;

counter = 1;
tic                                 % start time
while bk - ak >= l
    if Profit > theta_mk          % i.e. If profit with mk is higher
        ak = lk;
        lk = mk;
        mk = ak + alpha*(bk - ak);
        
        % Update lk, mk solutions
        Profit = theta_mk;
        problem.lk_SOLUTION = problem.mk_SOLUTION;
        [theta_mk, problem.mk_SOLUTION, values] = SimulatedAnnealing(problem, GreedySeats(mk, scenario));
        all_values.('run'+string(counter)) = values; counter = counter + 1;
        
    else                            % i.e. If profit with lk is higher
        bk = mk;
        mk = lk;
        lk = ak + (1 - alpha)*(bk - ak);
        
        % Update lk, mk solutions
        theta_mk = Profit;
        problem.mk_SOLUTION = problem.lk_SOLUTION;
        [Profit, problem.lk_SOLUTION, values] = SimulatedAnnealing(problem, GreedySeats(lk, scenario));
        all_values.('run'+string(counter)) = values; counter = counter + 1;
        
    end
    
    % Store progress (continuing from Greedy)
    ak_all = [ak_all, ak];
    bk_all = [bk_all, bk];
    lk_all = [lk_all, lk];
    mk_all = [mk_all, mk];
    
end
toc                                 % end time
%[optimal_profit_ak_sa, opt_ak_sa, values] = SimulatedAnnealing(problem, GreedySeats(ak, scenario));
%all_values.('run'+string(counter)) = values; counter = counter + 1;
%[optimal_profit_bk_sa, opt_bk_sa, values] = SimulatedAnnealing(problem, GreedySeats(bk, scenario));
%all_values.('run'+string(counter)) = values; counter = counter + 1;

fprintf('The optimal number of seats lies in interval: [%d %d]\n', ak, bk);
fprintf('The optimal profit is about: %d\n', (-Profit + -theta_mk)/2);
disp(ak_all)
disp(bk_all)
disp(problem.lk_SOLUTION)
disp(problem.mk_SOLUTION)

%% Plot objective values over iterations
% plot the values for each iteration
values = all_values.run1;
plot(values,'-ko');title('Objective function values over iterations');

% plot the best value
best_values = values(1);
for i=1:length(values)
    if(values(i)<best_values(end))
        best_values(i)=values(i);
    else
        best_values(i)=best_values(end);
    end
end
hold on;plot(best_values,'k:');
xlabel('Iteration');legend('iteration value','best value');